import { NextResponse } from 'next/server';
import prisma from '../../../lib/db'
import OpenAI from 'openai';
import { cookies } from 'next/headers';
import { verifyToken } from '../../../lib/auth.js';

const openai = process.env.OPENAI_API_KEY ? new OpenAI({ apiKey: process.env.OPENAI_API_KEY }) : null;

// Helper: Generate fake donor data
function generateFakeDonor(organizationId, isSimulated = true) {
  const firstNames = ['James', 'Mary', 'John', 'Patricia', 'Robert', 'Jennifer', 'Michael', 'Linda'];
  const lastNames = ['Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia', 'Miller', 'Davis'];
  const cities = ['New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix'];
  const professions = ['Engineer', 'Doctor', 'Teacher', 'Lawyer', 'Entrepreneur'];
  
  const firstName = firstNames[Math.floor(Math.random() * firstNames.length)];
  const lastName = lastNames[Math.floor(Math.random() * lastNames.length)];
  const email = `${firstName.toLowerCase()}.${lastName.toLowerCase()}${Math.floor(Math.random() * 100)}@example.com`;
  
  return {
    organizationId,
    firstName,
    lastName,
    email,
    phone: `+1${Math.floor(Math.random() * 9000000000) + 1000000000}`,
    preferredContact: ['EMAIL', 'PHONE', 'MAIL'][Math.floor(Math.random() * 3)],
    relationshipStage: ['NEW', 'CULTIVATION', 'ASK_READY', 'STEWARDSHIP'][Math.floor(Math.random() * 4)],
    status: Math.random() > 0.3 ? 'ACTIVE' : 'LYBUNT',
    isSimulated,
    notes: `Generated by AI system. ${firstName} is interested in our work.`,
    personalNotes: {
      interests: ['Education', 'Healthcare', 'Environment'].filter(() => Math.random() > 0.5),
      givingCapacity: Math.floor(Math.random() * 50000) + 1000,
      lastContact: new Date(Date.now() - Math.random() * 31536000000).toISOString(),
      communicationStyle: ['Formal', 'Casual', 'Direct', 'Conversational'][Math.floor(Math.random() * 4)],
      motivation: ['Personal connection', 'Tax benefits', 'Social impact', 'Community'][Math.floor(Math.random() * 4)]
    }
  };
}

// Helper: Generate AI response for donor
async function generateDonorResponse(donor, message, history = []) {
  if (!openai) {
    const responses = [
      "Thank you for reaching out. I appreciate your organization's work and would like to learn more about how my donation would be used.",
      "That's a great question. I've been supporting similar causes and would like to understand your specific impact metrics.",
      "I'm interested in learning about matching gift opportunities or other ways to maximize my contribution.",
      "Before making a decision, I'd like to understand your organization's long-term strategy and financial transparency.",
      "I appreciate you checking in. Could you tell me more about the specific programs my donation would support?"
    ];
    
    return {
      response: responses[Math.floor(Math.random() * responses.length)],
      sentiment: 'positive',
      suggestedAction: 'Follow up in 1 week',
      confidence: 0.8
    };
  }

  try {
    const donorNotes = donor.personalNotes || {};
    
    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        {
          role: "system",
          content: `You are ${donor.firstName} ${donor.lastName}, a donor with the following profile:
          
          Relationship Stage: ${donor.relationshipStage}
          Status: ${donor.status}
          Preferred Contact: ${donor.preferredContact}
          
          Personal Notes: ${JSON.stringify(donorNotes)}
          
          Previous giving: ${donorNotes.givingCapacity ? `Capacity: $${donorNotes.givingCapacity}` : 'Not specified'}
          Communication Style: ${donorNotes.communicationStyle || 'Balanced'}
          Interests: ${donorNotes.interests?.join(', ') || 'General philanthropy'}
          Motivation: ${donorNotes.motivation || 'Making a difference'}
          
          Respond as this donor would to a fundraiser. Be authentic to their personality and giving style.`
        },
        ...history.slice(-5).map(msg => ({
          role: msg.role === 'ai' ? 'assistant' : 'user',
          content: msg.content
        })),
        {
          role: "user",
          content: message
        }
      ],
      temperature: 0.7,
      max_tokens: 200
    });

    return {
      response: completion.choices[0].message.content,
      sentiment: 'positive',
      suggestedAction: 'Continue conversation',
      confidence: 0.9
    };
  } catch (error) {
    console.error('OpenAI error:', error);
    return {
      response: "I'm considering your question. Could you provide more details?",
      sentiment: 'neutral',
      suggestedAction: 'Clarify question',
      confidence: 0.6
    };
  }
}

// Helper: Generate assistant response
async function generateAssistantResponse(message, context = {}) {
  // High-quality fallback responses (used for offline or rate-limited states)
  const fallbackResponses = [
    "Based on donor engagement patterns, focusing on personalized follow-ups within 48 hours often improves retention.",
    "Donors who receive a thank-you touchpoint within 24 hours tend to stay more engaged over time.",
    "Segmenting donors by giving level can help you tailor communication more effectively.",
    "Many teams see stronger relationships when they use personal, story-driven updates instead of generic asks.",
    "Consistent, thoughtful communication builds trust long before the next donation request."
  ];

  // Helper to return a calm fallback
  const fallback = (confidence = 0.75) => ({
    response: fallbackResponses[Math.floor(Math.random() * fallbackResponses.length)],
    type: 'advice',
    confidence
  });

  // If OpenAI client isn't available, immediately fallback
  if (!openai) {
    return fallback(0.8);
  }

  try {
    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        {
          role: "system",
          content: `You are an AI fundraising expert. Provide concise, actionable advice for:
          
          1. Donor engagement and retention
          2. Fundraising strategy
          3. Donor communication
          4. Campaign planning
          5. Data analysis and insights
          
          Use data-driven recommendations when possible. Be practical and specific.`
        },
        {
          role: "user",
          content: message
        }
      ],
      temperature: 0.7,
      max_tokens: 250
    });

    return {
      response: completion.choices[0].message.content,
      type: 'advice',
      confidence: 0.9
    };

  } catch (error) {
    // üî¥ Detect rate limit explicitly
    const isRateLimit =
      error?.status === 429 ||
      error?.code === 'rate_limit_exceeded' ||
      error?.message?.toLowerCase().includes('rate');

    if (isRateLimit) {
      console.warn('OpenAI rate limit hit ‚Äî using fallback response');
      return fallback(0.7);
    }

    // ‚ùå Unknown error
    console.error('OpenAI error:', error);
    return {
      response:
        "I‚Äôm having trouble generating a response right now. You might find insight by reviewing recent donor interactions or engagement trends.",
      type: 'general',
      confidence: 0.6
    };
  }
}


export async function POST(request) {
  try {
    // Get token from cookies using your auth library
    const token = cookies().get('auth_token')?.value;
    
    if (!token) {
      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });
    }

    // Verify token using your auth library
    let user;
    try {
      user = await verifyToken(token);
    } catch (error) {
      console.error('Token verification error:', error);
      return NextResponse.json({ success: false, error: 'Invalid or expired token' }, { status: 401 });
    }

    console.log('HEADERS:', Object.fromEntries(request.headers));

    const body = await request.json();
    const { method, params } = body;
    const organizationId = user.organizationId;

    console.log('AI API Method:', method, 'Organization:', organizationId);

    switch (method) {
      // ============ CHAT METHODS ============
      case 'sendMessage': {
        const { message, context } = params;
        const response = await generateAssistantResponse(message, context);
        
        // Store in activity feed
        await prisma.activityFeed.create({
          data: {
            organizationId,
            userId: user.id,
            action: 'AI_CONSULTATION',
            title: 'AI Chat Consultation',
            description: `User asked: "${message.substring(0, 100)}..."`,
            metadata: { message, response },
            priority: 'NORMAL'
          }
        });

        return NextResponse.json({
          success: true,
          data: response
        });
      }

      case 'chatWithDonor': {
        const { donorId, message } = params;
        
        const donor = await prisma.donor.findFirst({
          where: { id: donorId, organizationId }
        });

        if (!donor) {
          return NextResponse.json({ success: false, error: 'Donor not found' }, { status: 404 });
        }

        // Get chat history
        const history = await prisma.communication.findMany({
          where: { donorId, organizationId },
          orderBy: { createdAt: 'desc' },
          take: 10,
          select: { content: true, direction: true, createdAt: true }
        });

        const response = await generateDonorResponse(donor, message, history);

        // Store communication
        await prisma.communication.create({
          data: {
            organizationId,
            donorId,
            type: 'EMAIL',
            direction: 'OUTBOUND',
            subject: 'AI Chat Conversation',
            content: `User: ${message}\n\nAI (as ${donor.firstName}): ${response.response}`,
            status: 'SENT',
            sentAt: new Date(),
            userId: user.id
          }
        });

        return NextResponse.json({
          success: true,
          data: {
            response: response.response,
            donor: {
              id: donor.id,
              name: `${donor.firstName} ${donor.lastName}`,
              relationshipStage: donor.relationshipStage
            },
            ...response
          }
        });
      }

      case 'organizationActivity': {
          const { limit = 25 } = params || {};

          if (!organizationId) {
            return NextResponse.json(
              { success: false, error: 'No organization ID' },
              { status: 400 }
            );
          }

          const activities = await prisma.activityFeed.findMany({
            where: {
              organizationId
            },

            take: limit,

            orderBy: {
              createdAt: 'desc'
            },

            include: {
              donor: {
                select: {
                  id: true,
                  firstName: true,
                  lastName: true
                }
              },

              user: {
                select: {
                  id: true,
                  name: true,
                  email: true
                }
              },

              donation: {
                select: {
                  id: true,
                  amount: true,
                  date: true
                }
              }
            }
          });

          return NextResponse.json({
            success: true,
            data: activities,
            count: activities.length
          });
        }


      // ============ DONOR MANAGEMENT ============
      case 'generateFakeDonors': {
        const { count = 5, isSimulated = true } = params;
        
        const donors = [];
        for (let i = 0; i < count; i++) {
          const donorData = generateFakeDonor(organizationId, isSimulated);
          const donor = await prisma.donor.create({
            data: donorData,
            include: { address: true }
          });
          donors.push(donor);
          
          // Create activity
          await prisma.donorActivity.create({
            data: {
              donorId: donor.id,
              organizationId,
              type: 'DONOR_CREATED',
              action: 'DONOR_GENERATED',
              title: 'AI Generated Donor',
              description: `Generated ${donor.firstName} ${donor.lastName} via AI system`,
              importance: 'NORMAL'
            }
          });
        }

        await prisma.activityFeed.create({
          data: {
            organizationId,
            userId: user.id,
            action: 'DONORS_GENERATED',
            title: 'AI Generated Donors',
            description: `Generated ${count} fake donors`,
            amount: count,
            metadata: { count, simulated: isSimulated },
            priority: 'NORMAL'
          }
        });

        return NextResponse.json({
          success: true,
          data: donors,
          count: donors.length
        });
      }

      case 'generateDonation': {
        const { donorId, amount = null, campaign = 'General Fund' } = params;
        
        const donor = await prisma.donor.findFirst({
          where: { id: donorId, organizationId }
        });

        if (!donor) {
          return NextResponse.json({ success: false, error: 'Donor not found' }, { status: 404 });
        }

        const donationAmount = amount || Math.floor(Math.random() * 5000) + 100;
        const paymentMethods = ['CREDIT_CARD', 'BANK_TRANSFER', 'CHECK'];

        // 1Ô∏è‚É£ Ensure the campaign exists
        const campaignRecord = await prisma.campaign.upsert({
          where: {
            organizationId_name: {
              organizationId,
              name: campaign
            }
          },
          update: {},
          create: {
            organizationId,
            name: campaign,
            status: 'ACTIVE'
          }
        });

                
        const donation = await prisma.donation.create({
          data: {
            organizationId,
            donorId,
            amount: donationAmount,
            paymentMethod: paymentMethods[Math.floor(Math.random() * paymentMethods.length)],
            date: new Date(),
            type: 'ONE_TIME',
            status: 'COMPLETED',
            campaignId: campaignRecord.id  // ‚úÖ THIS FIXES IT
          }
        });

        // Update donor status
        await prisma.donor.update({
          where: { id: donorId },
          data: { 
            status: 'ACTIVE',
            relationshipStage: 'STEWARDSHIP'
          }
        });

        // Create activities
        await Promise.all([
          prisma.donorActivity.create({
            data: {
              donorId,
              organizationId,
              type: 'DONATION',
              action: 'DONATION_RECEIVED',
              title: 'New Donation',
              description: `Received $${donationAmount} donation`,
              amount: donationAmount,
              relatedDonationId: donation.id,
              importance: 'HIGH'
            }
          }),
          prisma.activityFeed.create({
            data: {
              organizationId,
              donorId,
              userId: user.id,
              action: 'DONATION_RECEIVED',
              title: 'New Donation',
              description: `${donor.firstName} ${donor.lastName} donated $${donationAmount}`,
              amount: donationAmount,
              donationId: donation.id,
              metadata: { campaign, paymentMethod: donation.paymentMethod },
              priority: 'HIGH'
            }
          })
        ]);

        return NextResponse.json({
          success: true,
          data: donation
        });
      }

      case 'deleteDonor': {
        const { donorId } = params;
        
        const donor = await prisma.donor.findFirst({
          where: { id: donorId, organizationId }
        });

        if (!donor) {
          return NextResponse.json({ success: false, error: 'Donor not found' }, { status: 404 });
        }

        const wasSimulated = donor.isSimulated;
        
        await prisma.donor.delete({
          where: { id: donorId }
        });

        await prisma.activityFeed.create({
          data: {
            organizationId,
            userId: user.id,
            action: 'DONOR_DELETED',
            title: 'Donor Deleted',
            description: `Deleted ${donor.firstName} ${donor.lastName} ${wasSimulated ? '(simulated)' : ''}`,
            metadata: { donor: `${donor.firstName} ${donor.lastName}`, wasSimulated },
            priority: 'NORMAL'
          }
        });

        return NextResponse.json({
          success: true,
          data: { wasSimulated }
        });
      }

      // ============ DATA QUERIES ============
      case 'getDonors': {
        const { limit = 50, filters = {} } = params;
        
        const donors = await prisma.donor.findMany({
          where: { 
            organizationId,
            ...filters
          },
          include: {
            donations: {
              take: 5,
              orderBy: { date: 'desc' }
            },
            communications: {
              take: 3,
              orderBy: { sentAt: 'desc' }
            }
          },
          take: limit,
          orderBy: { updatedAt: 'desc' }
        });

        return NextResponse.json({
          success: true,
          data: donors,
          count: donors.length
        });
      }

      case 'getDonorDetails': {
        const { donorId } = params;
        
        const donor = await prisma.donor.findFirst({
          where: { id: donorId, organizationId },
          include: {
            donations: {
              orderBy: { date: 'desc' },
              include: { campaign: true }
            },
            communications: {
              orderBy: { sentAt: 'desc' },
              take: 10
            },
            pledges: {
              where: { status: 'ACTIVE' }
            },
            activities: {
              orderBy: { createdAt: 'desc' },
              take: 20
            },
            assignedTo: {
              select: { id: true, name: true, email: true }
            }
          }
        });

        if (!donor) {
          return NextResponse.json({ success: false, error: 'Donor not found' }, { status: 404 });
        }

        return NextResponse.json({
          success: true,
          data: donor
        });
      }

      case 'getRecentActivities': {
        const { limit = 20 } = params;
        
        const activities = await prisma.activityFeed.findMany({
          where: { organizationId },
          include: {
            donor: {
              select: { id: true, firstName: true, lastName: true }
            },
            user: {
              select: { id: true, name: true }
            },
            donation: {
              select: { id: true, amount: true }
            }
          },
          take: limit,
          orderBy: { createdAt: 'desc' }
        });

        return NextResponse.json({
          success: true,
          data: activities
        });
      }

      case 'getRecommendations': {
        // Get donors who haven't given in 6-12 months
        const lapsedDonors = await prisma.donor.findMany({
          where: {
            organizationId,
            status: 'LYBUNT',
            donations: {
              none: {
                date: {
                  gte: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000) // 1 year
                }
              }
            }
          },
          take: 5,
          select: {
            id: true,
            firstName: true,
            lastName: true,

            donations: { // ‚úÖ Correct relation
              select: {
                date: true,
                amount: true
              },
              orderBy: { date: 'desc' },
              take: 1
            }
          }
        });

        const recommendations = lapsedDonors.map(donor => ({
          id: `rec_${donor.id}`,
          type: 're-engagement',
          priority: 'high',
          title: `Re-engage ${donor.firstName} ${donor.lastName}`,
          description: 'Hasn\'t given in over a year',
          action: 'Send personalized re-engagement email',
          expectedImpact: '15% reactivation rate',
          donor: donor
        }));

        return NextResponse.json({
          success: true,
          data: recommendations
        });
      }

      // ============ SIMULATION CONTROL ============
      case 'startSimulationFlow': {
        const { donorCount = 50, interval = 10000 } = params;
        
        // Generate initial batch of simulated donors
        const donors = [];
        for (let i = 0; i < Math.min(donorCount, 20); i++) {
          const donorData = generateFakeDonor(organizationId, true);
          const donor = await prisma.donor.create({
            data: donorData
          });
          donors.push(donor);
        }

        await prisma.activityFeed.create({
          data: {
            organizationId,
            userId: user.id,
            action: 'SIMULATION_STARTED',
            title: 'AI Simulation Started',
            description: `Started donor simulation with ${donorCount} target donors`,
            metadata: { donorCount, interval },
            priority: 'HIGH'
          }
        });

        return NextResponse.json({
          success: true,
          data: {
            simulationId: `sim_${Date.now()}`,
            donorCount: donors.length,
            status: 'running'
          }
        });
      }

      case 'stopSimulation': {
        await prisma.activityFeed.create({
          data: {
            organizationId,
            userId: user.id,
            action: 'SIMULATION_STOPPED',
            title: 'AI Simulation Stopped',
            description: 'Stopped donor simulation',
            priority: 'NORMAL'
          }
        });

        return NextResponse.json({
          success: true,
          data: { message: 'Simulation stopped' }
        });
      }

      default:
        return NextResponse.json({
          success: false,
          error: `Unknown method: ${method}`
        }, { status: 400 });
    }
  } catch (error) {
    console.log('Cookies:', cookies().getAll());
    console.error('API Error:', error);
    return NextResponse.json({
      success: false,
      error: error.message || 'Internal server error'
    }, { status: 500 });
  } finally {
    await prisma.$disconnect();
  }
}

export async function GET(request) {
  try {
    // Get token from cookies
    const token = cookies().get('auth_token')?.value;
    
    if (!token && process.env.NODE_ENV === 'production') {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // For development, allow without token but with a warning
    let user = null;
    if (token) {
      try {
        user = await verifyToken(token);
      } catch (error) {
        console.error('Token verification error:', error);
        if (process.env.NODE_ENV === 'production') {
          return NextResponse.json({ success: false, error: 'Invalid token' }, { status: 401 });
        }
      }
    }

    console.log('User:', user);
    console.log('ORG:', request.headers.get('x-org-id'));

    const url = new URL(request.url);
    const method = url.searchParams.get('method');
    const params = {};

    for (const [key, value] of url.searchParams.entries()) {
      if (key !== 'method') {
        try {
          params[key] = JSON.parse(value);
        } catch {
          params[key] = value;
        }
      }
    }

    switch (method) {
      case 'health':
        return NextResponse.json({
          success: true,
          data: {
            status: 'healthy',
            timestamp: new Date().toISOString(),
            version: '1.0.0',
            authenticated: !!user
          }
        });

      default:
        return NextResponse.json({
          success: false,
          error: `GET not supported for method: ${method}. Use POST instead.`
        }, { status: 405 });
    }
  } catch (error) {
    console.error('GET API Error:', error);
    return NextResponse.json({
      success: false,
      error: error.message || 'Internal server error'
    }, { status: 500 });
  }
}